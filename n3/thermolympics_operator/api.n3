@prefix : <http://f4w.restdesc.org/demo#>.
@prefix http: <http://www.w3.org/2011/http#>.
@prefix tmpl: <http://multimedialab.elis.ugent.be/organon/ontologies/tmpl#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#>.
@prefix out: <http://f4w.restdesc.org/demo/.well-known/genid/f3ed8675-47ce-42f1-ac89-9082b146b6db#>.

# API USER 1 (ask for a part ID, might want to send all available part IDs but no API for this atm)
{
    log:Truth.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/getPartID");
              http:body {[
                  :message "Please provide the part ID you want to work with."
              ]};
              http:resp [
                  http:body _:body
              ].
    _:body :contains {[
        :id ?n
    ]}.
    _:part a :part;
           :id ?n.
}.

# API 1 (request all defects for a given part ID)
{
    ?part a :part;
          :id ?n.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://thermolympic-demo.herokuapp.com/defects?part_id=" ?n);
              http:resp [
                  http:body _:list
              ].
    ?part :defectList _:list.
}.


# API USER 2 (ask the user to create a report with an existing defect or by creating a new one)
{
    ?part a :part;
          :id ?n;
          :defectList ?list.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/getReport");
              http:body {[
                  :message "Please report the defect.";
                  :defectList ?list
              ]};
              http:resp [
                  http:body _:body
              ].
    _:body :contains {[
        :defect ?d;
        :operator ?o
    ]}.
    _:report a :report;
             :part ?part;
             :operator ?o;
             :defect ?d.
}.
# TODO: maybe should have generic solution for this
# needs to be outside of the API rule to not end up in the actual data with skolemized URIs for all possible contents
{
    ?report :defect ?defect.
    ?defect e:label ?label. # only necessary when ?defect isn't grounded, if it is we have the actual object
}
=>
{
    ?x :solution_used {[
        :id _:id
    ]}.
    ?x :solution_used {[
        :name _:name;
        :description _:description;
        :picture _:picture;
        :comment _:comment
    ]}.
}.

# Create a new defect if necessary
{
    ?report a :report;
            :part ?part;
            :defect ?defect.
    ?part a :part;
          :id ?n.
    ?defect log:includes {
        ?d :name ?name;
           :description ?description;
           :picture ?picture;
           :comment ?comment
    }.
}
=>
{
    _:request http:methodName "POST";
              tmpl:requestURI ("http://thermolympic-demo.herokuapp.com/defects");
              http:body {[
                  :part_id ?id;
                  :name ?name;
                  :description ?description;
                  :picture ?picture;
                  :comment ?comment
              ]};
              http:resp [
                  http:body _:body
              ].
    _:body :contains {[
        :id ?id
    ]}.
    ?report :defect {[ :id ?id ]}.
}.

# POST new report
{
    ?report a :report;
              :part ?part;
              :operator ?operator;
              :defect ?defect.
    ?defect log:includes { ?d :id ?id }.
}
=>
{
    _:request http:methodName "POST";
              tmpl:requestURI ("http://thermolympic-demo.herokuapp.com/reports");
              http:body {[
                  :defect_id ?id;
                  :operator ?operator
              ]}.
    ?report :is :posted.
}.