# http://facts4workers.surge.sh/

@prefix : <http://f4w.restdesc.org/demo#>.
@prefix teamleader: <http://f4w.restdesc.org/demo/teamleader#>.
@prefix tho: <http://f4w.restdesc.org/demo/thermolympic#>.
@prefix rest: <http://f4w.restdesc.org/demo#>.
@prefix http: <http://www.w3.org/2011/http#>.
@prefix tmpl: <http://purl.org/restdesc/http-template#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix util: <http://f4w.restdesc.org/util#>.
@prefix auth: <http://f4w.restdesc.org/demo/authorization#>.

{
    ?list a tho:operatorList
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/getOperatorID");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              http:body { rest:json
                  :sendList ?list
              };
              http:resp [
                  http:body _:body
              ].
    _:body rest:contains { rest:json
        :id _:id
    }.
    _:problem a teamleader:problem;
              teamleader:operator [ teamleader:id _:id ]
}.

# get machine ID from operator
{
    ?problem a teamleader:problem;
             teamleader:operator ?operator.
    ?list a tho:machineList.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/getMachineID");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              rest:check ?problem;
              http:body { rest:json
                  :sendList ?list
              };
              http:resp [
                  http:body _:body
              ].
    _:body rest:contains { rest:json
        :id _:id
    }.
    ?problem teamleader:machine [ teamleader:id _:id ].
}.

# get last event for given machine
{
    ?problem a teamleader:problem;
             teamleader:machine ?machine.
    ?machine teamleader:id ?machine_id.
    ?user auth:authenticated true.
    ?user auth:access_token ?token.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://mstate.tho.f4w.l0g.in/api/machines/" ?machine_id "/last_event?access_token=" ?token);
              http:resp [
                  http:body _:body
              ].
    _:body rest:contains { rest:json
        :id _:id;
        # TODO: same problem as other APIs with multiple options: optional could be empty (if machine is not stopped for example)
        :optional _:optional
    }.
    ?problem teamleader:event [ teamleader:id _:id;
                                teamleader:optional _:optional ].
}.
# TODO: problem with 'optional' being, well, optional
{
    ?problem teamleader:event ?event.
    ?event teamleader:optional ?optional.
    ?optional e:label ?label.
}
=>
{
    ?event teamleader:defect [ teamleader:id _:defect_id ];
           teamleader:original [ teamleader:id _:original_id ].
}.
{
    ?problem teamleader:event ?event.
    ?event teamleader:optional ?optional.
    ?optional log:includes { ?x :defect_id ?did; :stopped_for_defect_event_id ?oid }. # TODO: can't use teamleader prefix here since it's coming from JSON...
}
=>
{
    # TODO: do these need to be grounded at this point? can be created at the end of another rule to force grounding?
    ?event teamleader:defect teamleader:defect;
           teamleader:original teamleader:original.
    teamleader:defect teamleader:id ?did.
    teamleader:original teamleader:id ?oid.
}.
{
    ?problem teamleader:event ?event.
    ?event teamleader:optional ?optional.
    ?optional e:notLabel ?label. # important so it doesn't match when it's still a blank node
    ?optional log:notIncludes { ?x :defect_id ?did; :stopped_for_defect_event_id ?oid }. # TODO: can't use teamleader prefix here since it's coming from JSON...
}
=>
{
    ?problem teamleader:state teamleader:ok.
}.

# get all events if there is no actual problem with the machine
{
    ?problem a teamleader:problem;
             teamleader:machine ?machine.
    ?machine teamleader:id ?machine_id.
    ?user auth:authenticated true.
    ?user auth:access_token ?token.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://mstate.tho.f4w.l0g.in/api/machines/" ?machine_id "/events?access_token=" ?token);
              http:resp [
                  http:body _:list
              ].
    ?machine teamleader:events _:list.
}.

# send all events to the worker if there is nothing to do
{
    ?problem a teamleader:problem;
             teamleader:machine ?machine;
             teamleader:state teamleader:ok.
    ?machine teamleader:events ?events.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/events");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              http:body { rest:json
                  :events ?events
              }.
    ?problem teamleader:state teamleader:sentEvents.
}.


# if the machine is working we are done after sending the events
{
    ?problem a teamleader:problem;
             teamleader:state teamleader:ok;
             teamleader:state teamleader:sentEvents.
}
=>
{
    ?problem teamleader:state teamleader:resolved.
}.


# get solutions
{
    ?problem teamleader:event ?event.
    ?event teamleader:defect ?defect.
    ?defect teamleader:id ?defect_id.
    ?user auth:authenticated true.
    ?user auth:access_token ?token.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://defects.tho.f4w.l0g.in/api/solutions?defect_id=" ?defect_id "&access_token=" ?token);
              http:resp [
                  http:body _:list
              ].
    ?defect teamleader:solutions _:list.
}.

# get corresponding reports
{
    ?problem teamleader:event ?event.
    ?event teamleader:original ?original.
    ?original teamleader:id ?original_id.
    ?user auth:authenticated true.
    ?user auth:access_token ?token.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://defects.tho.f4w.l0g.in/api/reports?event_id=" ?original_id  "&access_token=" ?token);
              http:resp [
                  http:body _:list
              ].
    ?original teamleader:reports _:list.
}.

# get defect information to send to user
{
    ?problem a teamleader:problem;
               teamleader:event ?event.
    ?event teamleader:defect ?defect.
    ?defect teamleader:id ?defect_id.
    ?user auth:authenticated true.
    ?user auth:access_token ?token.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://defects.tho.f4w.l0g.in/api/defects/" ?defect_id "?access_token=" ?token);
              http:resp [
                  http:body _:body
              ].

    _:body rest:contains { rest:json
        :name _:name;
        :desc _:desc;
        :part_id _:part_id;
        :media_url _:media_url;
        :comment _:comment;
        :created_at _:created_at
    }.
    # TODO: @doerthe: an easier way to copy like this?
    ?defect  teamleader:name _:name;
             teamleader:desc _:desc;
             teamleader:part_id _:part_id;
             teamleader:media_url _:media_url;
             teamleader:comment _:comment;
             teamleader:created_at _:created_at.
}.

# TODO: copied from operator, need 1 building block, also, no way currently to get info for 1 part
{
    ?problem a teamleader:problem;
             teamleader:machine ?machine.
    ?machine teamleader:id ?machine_id.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://machinesandparts.surge.sh/api/parts.json");
              http:resp [
                  http:body _:list
              ].
    _:list a teamleader:partList.
}.

{
    ?problem a teamleader:problem.
    ?event teamleader:defect ?defect.
    ?defect teamleader:part_id ?part_id.

    ?list a teamleader:partList.

    (?list {?s :id ?part_id}) util:filter ?parts.

    (?parts 0) util:select ?part.
}
=>
{
    ?problem teamleader:part ?part.
}.

# TODO: should be able to do looping without this rule
# create dummy report to trigger first instance of rule
{
    ?problem a teamleader:problem.
}
=>
{
    :dummy_report a teamleader:report;
                  teamleader:success false;
                  teamleader:state teamleader:posted.
}.


# TODO: duplication due to 2 different situations
# send all events to the worker if there is nothing to do
{
    ?problem a teamleader:problem;
             teamleader:machine ?machine;
             teamleader:event ?event;
             teamleader:part ?part.

    ?machine teamleader:events ?events.

    ?event teamleader:defect ?defect;
           teamleader:original ?original.

    ?defect  teamleader:name ?name;
             teamleader:desc ?desc;
             teamleader:media_url ?media_url;
             teamleader:comment ?comment;
             teamleader:created_at ?created.

    ?original teamleader:reports ?reports.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/events");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              http:body { rest:json
                  :part ?part;
                  :defect { rest:json
                      :name ?name;
                      :desc ?desc;
                      :media_url ?media_url;
                      :comment ?comment;
                      :created_at ?created
                  };
                  :reports ?reports;
                  :events ?events
              }.
    ?problem teamleader:state teamleader:sentEvents;
             teamleader:hack _:hack. # TODO: ...
}.

# request solution if the previous report failed
{
    ?problem teamleader:event ?event;
             teamleader:operator ?operator;
             teamleader:hack ?hack.

    ?event teamleader:defect ?defect;
           teamleader:original ?original.
    ?defect teamleader:solutions ?solutions.

    ?report a teamleader:report;
            teamleader:success ?success;
            teamleader:state teamleader:posted.
    ?success e:whenGround {?success log:equalTo false}.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/getSolutionID");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              rest:check ?hack;
              rest:check ?report;
              http:body { rest:json
                  :message "Choose one of the following solutions.";
                  :solutions ?solutions
              };
              http:resp [
                  http:body _:body
              ].
    _:body rest:contains { rest:json
        :id _:id;
    }.

    _:report a teamleader:report;
               teamleader:event ?original;
               teamleader:operator ?operator;
               teamleader:solution [ teamleader:id _:id ].

    _:report util:loop true.
}.

# TODO: extend precondition?
# request report if the previous report failed
{
    ?report a teamleader:report;
            teamleader:solution ?sol.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/getReport");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              rest:check ?sol;
              http:resp [
                  http:body _:body
              ].
    _:body rest:contains { rest:json
        :success _:success;
        :comment _:comment
    }.
    ?report teamleader:success _:success;
            teamleader:comment _:comment.
}.

# POST report
{
    ?report a teamleader:report;
            teamleader:event ?event;
            teamleader:operator ?operator;
            teamleader:solution ?solution;
            teamleader:success ?success;
            teamleader:comment ?comment.
    ?event teamleader:id ?event_id.
    ?operator teamleader:id ?operator_id.
    ?solution teamleader:id ?solution_id.
    ?user auth:authenticated true.
    ?user auth:access_token ?token.
}
=>
{
    _:request http:methodName "POST";
              tmpl:requestURI ("http://defects.tho.f4w.l0g.in/api/reports?access_token=" ?token);
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              http:body { rest:json
                  :event_id ?event_id;
                  :operator_id ?operator_id;
                  :solution_id ?solution_id;
                  :success ?success;
                  :comment ?comment
              };
              http:resp [
                  http:body _:body
              ].
    _:body rest:contains { rest:json
        :id _:id
    }.
    ?report teamleader:id _:id;
            teamleader:state teamleader:posted.
    # TODO: append to list of reports? (always send those to worker?)
}.


#TODO: Can we make that one rule for operator and teamleader?
# update machine status if there was a succesful report
{
    ?problem teamleader:operator ?operator;
             teamleader:machine ?machine;
             teamleader:event ?event.
    ?machine teamleader:id ?machine_id.
    ?event teamleader:original ?original.
    ?report a teamleader:report;
            teamleader:event ?original;
            teamleader:state teamleader:posted;
            teamleader:success ?success.
    ?success e:whenGround {?success log:equalTo true}.
    ?operator teamleader:id ?operator_id.
    ?user auth:authenticated true.
    ?user auth:access_token ?token.
}
=>
{
    _:request http:methodName "POST";
              tmpl:requestURI ("http://mstate.tho.f4w.l0g.in/api/machines/" ?machine_id "/events?access_token=" ?token);
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              rest:check ?success; # TODO: a bit annoying
              http:body { rest:json
                  :name "Teamleader maintenance finished.";
                  :desc "Machine fixed.";
                  :machine_state 1;
                  :operator_id ?operator_id
              }.
    ?problem teamleader:state teamleader:resolved.
}.
