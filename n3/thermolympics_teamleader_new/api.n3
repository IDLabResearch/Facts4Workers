# http://facts4workers.surge.sh/

@prefix : <http://f4w.restdesc.org/demo#>.
@prefix rest: <http://f4w.restdesc.org/restdesc#>.
@prefix http: <http://www.w3.org/2011/http#>.
@prefix tmpl: <http://purl.org/restdesc/http-template#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix util: <http://f4w.restdesc.org/util#>.

# get teamleader operator ( TODO: probably should use same rule as worker part)
{
    log:Truth
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://skillp.tho.f4w.l0g.in/api/operator_skills/");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              http:resp [
                  http:body _:list
              ].
    _:list a :operatorSkillList.
}.

# TODO: extra rule :operatorSkillList -> :operatorList ?

{
    ?list a :operatorSkillList
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/getOperatorID");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              http:body { rest:json
                  :sendList ?list
              };
              http:resp [
                  http:body _:body
              ].
    _:body :contains { rest:json
        :id _:id
    }.
    _:problem a :problem;
              :operator [ :id _:id ]
}.

# TODO: some copy/paste here from other THO api rules
#get machine id list
{
    log:Truth.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://mstate.tho.f4w.l0g.in/api/machines");
              http:resp [
                  http:body _:list
              ].
    _:list a :machineList.
}.

# get machine ID from operator
{
    ?problem a :problem;
             :operator ?operator.
    ?list a :machineList.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/getMachineID");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              :check ?problem;
              http:body { rest:json
                  :sendList ?list
              };
              http:resp [
                  http:body _:body
              ].
    _:body :contains { rest:json
        :id _:id
    }.
    ?problem :machine [ :id _:id ].
}.

# get last event for given machine
{
    ?problem a :problem;
             :machine ?machine.
    ?machine :id ?machine_id.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://mstate.tho.f4w.l0g.in/api/machines/" ?machine_id "/last_event");
              http:resp [
                  http:body _:body
              ].
    _:body :contains { rest:json
        :id _:id;
        # TODO: same problem as other APIs with multiple options: optional could be empty (if machine is not stopped for example)
        :optional _:optional
    }.
    ?problem :event [ :id _:id;
                      :optional _:optional ].
}.
# TODO: problem with 'optional' being, well, optional
{
    ?problem :event ?event.
    ?event :optional ?optional.
    ?optional e:label ?label.
}
=>
{
    ?event :defect [ :id _:defect_id ];
           :original [ :id _:original_id ].
}.
{
    ?problem :event ?event.
    ?event :optional ?optional.
    ?optional log:includes { ?x :defect_id ?did; :stopped_for_defect_event_id ?oid }.
}
=>
{
    # TODO: do these need to be grounded at this point? can be created at the end of another rule to force grounding?
    ?event :defect :defect;
           :original :original.
    :defect :id ?did.
    :original :id ?oid.
}.
{
    ?problem :event ?event.
    ?event :optional ?optional.
    ?optional e:notLabel ?label. # important so it doesn't match when it's still a blank node
    ?optional log:notIncludes { ?x :defect_id ?did; :stopped_for_defect_event_id ?oid }.
}
=>
{
    ?problem :state :ok.
}.

# get all events if there is no actual problem with the machine
{
    ?problem a :problem;
             :state :ok;
             :machine ?machine.
    ?machine :id ?machine_id.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://mstate.tho.f4w.l0g.in/api/machines/" ?machine_id "/events");
              http:resp [
                  http:body _:list
              ].
    ?machine :events _:list.
}.

# send all events to the worker if there is nothing to do
{
    ?problem a :problem;
             :state :ok;
             :machine ?machine.
    ?machine :events ?events.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/events");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              http:body { rest:json
                  :events ?events
              }.
    ?problem :state :resolved.
}.

# get solutions
{
    ?problem :event ?event.
    ?event :defect ?defect.
    ?defect :id ?defect_id.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://defects.tho.f4w.l0g.in/api/solutions?defect_id=" ?defect_id);
              http:resp [
                  http:body _:list
              ].
    ?defect :solutions _:list.
}.

# get corresponding reports
{
    ?problem :event ?event.
    ?event :original ?original.
    ?original :id ?original_id.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://defects.tho.f4w.l0g.in/api/reports?event_id=" ?original_id);
              http:resp [
                  http:body _:list
              ].
    ?original :reports _:list.
}.

# get defect information to send to user
{
    ?problem a :problem;
               :event ?event.
    ?event :defect ?defect.
    ?defect :id ?defect_id.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://defects.tho.f4w.l0g.in/api/defects/" ?defect_id);
              http:resp [
                  http:body _:body
              ].

    _:body :contains { rest:json
        :name _:name;
        :desc _:desc;
        :part_id _:part_id;
        :media_url _:media_url;
        :comment _:comment;
        :created_at _:created_at
    }.
    # TODO: @doerthe: an easier way to copy like this?
    ?defect  :name _:name;
             :desc _:desc;
             :part_id _:part_id;
             :media_url _:media_url;
             :comment _:comment;
             :created_at _:created_at.
}.

# TODO: copied from operator, need 1 building block, also, no way currently to get info for 1 part
{
    ?problem a :problem;
             :machine ?machine.
    ?machine :id ?machine_id.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://machinesandparts.surge.sh/api/parts.json");
              http:resp [
                  http:body _:list
              ].
    _:list a :partList.
}.

{
    ?problem a :problem.
    ?event :defect ?defect.
    ?defect :part_id ?part_id.

    ?list a :partList.

    _:x e:findall (?e {?e list:in ?list. ?e log:includes {?s :id ?part_id}} ?parts).
    ?parts log:conjunction ?part. # TODO: @Doerthe: this is not really getting the first element
}
=>
{
    ?problem :part ?part.
}.

# send solutions and reports to teamleader
{
    ?problem :event ?event;
             :operator ?operator.
    ?problem :part ?part.

    ?event :defect ?defect.
    ?defect :solutions ?solutions.

    ?defect  :name ?name;
             :desc ?desc;
             :media_url ?media_url;
             :comment ?comment;
             :created_at ?created.

    ?event :original ?original.
    ?original :reports ?reports.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/solutionsReports");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              http:body { rest:json
                  :part ?part;
                  :defect { rest:json
                      :name ?name;
                      :desc ?desc;
                      :media_url ?media_url;
                      :comment ?comment;
                      :created_at ?created
                  };
                  :solutions ?solutions;
                  :reports ?reports
              }.
    # dummy report to trigger next rule
    _:report a :report;
             :event ?original;
             :success false;
             :state :posted.
}.

# request report if the previous report failed
{
    ?problem :event ?event;
             :operator ?operator.
    ?event :original ?original.
    ?report a :report;
            :event ?original;
            :success ?success;
            :state :posted.
    ?success e:whenGround false.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/getReport");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              :check ?report;
              http:resp [
                  http:body _:body
              ].
    _:body :contains { rest:json
        :solution_id _:solution_id;
        :success _:success;
        :comment _:comment
    }.
    _:report a :report;
             :event ?original;
             :operator ?operator;
             :solution [ :id _:solution_id ];
             :success _:success;
             :comment _:comment.
    _:report util:loop true.
}.

# POST report
{
    ?report a :report;
            :event ?event;
            :operator ?operator;
            :solution ?solution;
            :success ?success;
            :comment ?comment.
    ?event :id ?event_id.
    ?operator :id ?operator_id.
    ?solution :id ?solution_id.
}
=>
{
    _:request http:methodName "POST";
              tmpl:requestURI ("http://defects.tho.f4w.l0g.in/api/reports");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              http:body { rest:json
                  :event_id ?event_id;
                  :operator_id ?operator_id;
                  :solution_id ?solution_id;
                  :success ?success;
                  :comment ?comment
              };
              http:resp [
                  http:body _:body
              ].
    _:body :contains { rest:json
        :id _:id
    }.
    ?report :id _:id;
            :state :posted.
    # TODO: append to list of reports? (always send those to worker?)
}.

# update machine status if there was a succesful report
{
    ?problem :operator ?operator;
             :machine ?machine;
             :event ?event.
    ?machine :id ?machine_id.
    ?event :original ?original.
    ?report a :report;
            :event ?original;
            :state :posted;
            :success ?success.
    ?success e:whenGround true.
    ?operator :id ?operator_id.
}
=>
{
    _:request http:methodName "POST";
              tmpl:requestURI ("http://mstate.tho.f4w.l0g.in/api/machines/" ?machine_id "/events/");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              :check ?success; # TODO: a bit annoying
              http:body { rest:json
                  :name "Teamleader maintenance finished.";
                  :desc "Machine fixed.";
                  :machine_state 4;
                  :operator_id ?operator_id
              }.
    ?problem :state :resolved.
}.