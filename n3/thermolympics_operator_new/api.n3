# https://thermolympic-demo.herokuapp.com/api_doc/

@prefix : <http://f4w.restdesc.org/demo#>.
@prefix operator: <http://f4w.restdesc.org/demo/operator#>.
@prefix tho: <http://f4w.restdesc.org/demo/thermolympic#>.
@prefix rest: <http://f4w.restdesc.org/restdesc#>.
@prefix http: <http://www.w3.org/2011/http#>.
@prefix tmpl: <http://purl.org/restdesc/http-template#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#>.
@prefix out: <http://f4w.restdesc.org/demo/.well-known/genid/f3ed8675-47ce-42f1-ac89-9082b146b6db#>.
@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix string: <http://www.w3.org/2000/10/swap/string#>.

:thereIsADefect a operator:problem.
:thereIsADefect :trySolution :firstTry.
:firstTry :solutionNo 1.

{
    ?list a tho:operatorList.
    ?problem a operator:problem.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/getOperatorID");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              http:body { rest:json
                  :message "Who are you? Please send your id from the list.";
                  :sendList ?list
              };
              http:resp [
                  http:body _:body
              ].
    _:body :contains {
        [:id _:n]
    }.
    _:newOperatorURI a :operator;
        :operatorId _:n;
        :foundProblem ?problem.
}.

#get machine id list
{
    log:Truth.
}
=>{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://mstate.tho.f4w.l0g.in/api/machines");
              http:resp [
                  http:body _:list
              ].
    _:list a :machineList.
}.

#get machine id
{
    ?list a :machineList.
    ?operator :foundProblem ?problem.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/getMachineID");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              :check ?operator;
              http:body { rest:json
                  :message "On what machine are you working?";
                  :sendList ?list
              };
              http:resp [
                  http:body _:body
              ].
    _:body :contains {
        _:operator  :id _:n
    }.
    _:newMachineURI a :machine;
                    :machineID _:n.
    ?problem :occurredOnMachine _:newMachineURI.
}.

#get parts
{
    ?problem :occurredOnMachine ?machine. ?machine :machineID ?n.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://machinesandparts.surge.sh/api/parts.json");
              http:resp [
                  http:body _:list
              ].
    _:list a :partList.
}.

# API USER 1 (ask for a part ID, might want to send all available part IDs but no API for this atm)
{
    ?problem :occurredOnMachine ?machine. ?machine :machineID ?n.
    ?list a :partList.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/getPartID");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              http:body { rest:json
                  :message "Please provide the ID of the part on which the problem occurred.";
                  :machine ?n;
                  :parts ?list
              };
              http:resp [
                  http:body _:body
              ].
    _:body :contains { rest:json
        :id _:n
    }.
    ?problem :occurredOnPartWithID _:n.
}.

#Problem is HERE
#get defect id list
{
?problem :occurredOnPartWithID ?p
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://defects.tho.f4w.l0g.in/api/defects?part_id=" ?p);
              http:resp [
                  http:body _:list2
              ].
    _:list2 a :defectList.
}.

# API USER 2 (ask the user for a defect id)
{
    ?list a :defectList.
    ?operator :foundProblem ?problem.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/getDefectID");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              http:body { rest:json
                  :message "Please report the defect.";
                  :sendList ?list
              };
              http:resp [
                  http:body _:body
              ].
    _:body :contains { rest:json
        :id _:d;
    }.
    ?problem :defect _:d.
}.


#get solution id list
{
    ?problem :defect ?id;
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://defects.tho.f4w.l0g.in/api/solutions?defect_id=" ?id);
              http:resp [
                  http:body _:list
              ].
    _:list a :solutionList.
}.

#choose a solution
{
    ?list a :solutionList.
    ?problem :trySolution ?sol.
}=>{
    _:request http:methodName "GET";
              :check ?sol;
              tmpl:requestURI ("http://askTheWorker/getSolutionID");
              http:headers ([ http:fieldName "Content-Type" ; http:fieldValue "application/json" ]);
              http:body { rest:json
                  :message "Choose one of the following solutions.";
                  :sendList ?list
              };
              http:resp [
                  http:body _:body
              ].
    _:body :contains { rest:json
        :id _:d;
    }.
    ?sol :solutionId _:d.
}.

#solution has no result yet?
{
    ?solution :solutionId ?id.
    _:x e:findall (?solution {?solution :triedAndReported "yes"} ()).
}
=>
{
    ?solution :triedAndReported "no"
}.


#get operator skills
{
    ?operator :foundProblem ?problem;
:operatorId ?id.
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://skillp.tho.f4w.l0g.in/api/operator_skills/" ?id);
              http:resp [
                  http:body _:body
              ].
    _:body :contains { rest:json
        :name _:name;
        :desc _:desc;
        :role _:role;
        :skills { rest:json :machine _:m; :tool _:t; :computer _:c }
    }.
    ?operator :machineSkills _:m;
        :toolSkills _:t;
        :computerSkills _:c.
    ?operator :name _:name;
              :desc _:desc;
              :role _:role.
}.

#get skills required for solution
{
    ?problem :defect ?id;
             :trySolution ?solution.
    ?solution :solutionId ?sid.
    ?solution :requiredSkillsKnown "no".
}=>{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://defects.tho.f4w.l0g.in/api/solutions/" ?sid);
              http:resp [
                  http:body _:body
              ].
    _:body :contains { rest:json
        :name _:name;
        :desc _:desc;
        :comment _:comment;
        :skill { rest:json :machine _:m; :tool _:t; :computer _:c }
    }.
    ?solution :reqMachineSkills _:m;
         :reqToolSkills _:t;
         :reqComputerSkills _:c. #problem: sometimes no computer value
    ?solution :requiredSkillsKnown ?yes. #please ground with "yes"
    ?solution :name _:name;
              :desc _:desc;
              :comment _:comment.
}.


{
    ?problem :defect ?id;
             :trySolution ?solution.
    ?solution :solutionId ?sid.
    _:e e:findall(?s {?solution :requiredSkillsKnown "yes"} ()).
}
=>
{
    ?solution :requiredSkillsKnown "no".
}.


{?solution :solutionId ?sid. ?solution2 :solutionId ?sid.
 ?solution :reqMachineSkills ?ms; :reqToolSkills ?t; :reqComputerSkills ?c. ?solution :requiredSkillsKnown "yes"
}=>{?solution2 :reqMachineSkills ?ms; :reqToolSkills ?t; :reqComputerSkills ?c. ?solution2 :requiredSkillsKnown "yes"}.




#has the machine been stopped?
{?problem :occurredOnMachine ?m. _:l e:findall (?x {?m :state "stopped1"} ()) }=>{ ?m :state "notstopped1" }.


{?problem :occurredOnMachine ?m. _:l e:findall (?x {?m :state "stopped2"} ()) }=>{ ?m :state "notstopped2" }.



#stop the machine and get id
{
    ?problem :occurredOnMachine ?m;
             :defect ?defectID.
    ?m :machineID ?machineID.
    ?m :state "notstopped1".
    ?operator :foundProblem ?problem;
              :operatorId ?wid.

}
=>
{
    _:request http:methodName "POST";
              tmpl:requestURI ("http://mstate.tho.f4w.l0g.in/api/machines/" ?machineID "/events");
              http:body { rest:json
                  :name "Stop the machine";
                  :desc "Stoping the machine after a defect was spotted!";
                  :machine_state "4";
                  :operator_id ?wid;
                  :optional { rest:json :defect_id ?defectID }
              };
              http:resp [
                  http:body _:body
              ].
    _:body :contains { rest:json
        :id _:e
    }.
    {?m :state "stopped1".} :eventId _:e.
    ?m :state _:stopped1. #please put "stopped1" here when grounding.
}.

{
    ?problem :trySolution ?solution.
    ?solution :solutionId ?id.
    _:e e:findall (?solution {?solution :tried "yes"} ()).
}
=>
{
    ?solution :tried "no"
}.

{?solution :worked true.}=>{?solution :tried "yes"}.
{?solution :worked false.}=>{?solution :tried "yes"}.

# report the result
{
    ?operator :foundProblem ?problem;
         :operatorId ?wid;
         :machineSkills ?wm;
         :toolSkills ?wt;
         :computerSkills ?wc.
    ?operator :name ?w_name;
              :desc ?w_desc;
              :role ?w_role.

    ?problem :occurredOnMachine ?m.
    ?m :machineID ?machineID.
    {?m :state ?stopped1.} :eventId ?e.
    ?problem :trySolution ?solution.
    ?solution :solutionId ?id;
              :tried "no";
              :triedAndReported "no".
    ?solution :reqMachineSkills ?ms;
        :reqToolSkills ?t;
        :reqComputerSkills ?c.
    ?solution :name ?s_name;
              :desc ?s_desc;
              :comment ?s_comment.

    (?wm ?wt ?wc ?ms ?t ?c) e:whenGround (?wm2 ?wt2 ?wc2 ?m2 ?t2 ?c2).

    (?wm2 ?wt2 ?wc2) :match (?m2 ?t2 ?c2).
}
=>
{
    _:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/getReport");
              :check (?wm ?ms);
              http:body { rest:json
                  :message "Report the outcome.";
                  :solution { rest:json
                      :id ?id;
                      :name ?s_name;
                      :desc ?s_desc;
                      :comment ?s_comment
                  };
                  :operator { rest:json
                      :id ?wid;
                      :name ?w_name;
                      :desc ?w_desc;
                      :role ?w_role
                  };
                  :machineId ?machineID;
                  :eventId ?e
              };
              http:resp [
                  http:body _:body
              ].
    _:body :contains { rest:json
        :solved _:yn;
        :comment _:comment
    }.
    ?solution :worked _:yn;
              :report_comment _:comment.
}.


# skill-matching
{
    (?wm ?wt ?wc) :match (?m ?t ?c).
}
<=
{
    ?m math:notGreaterThan ?wm.
    ?t math:notGreaterThan ?wt.
    ?c math:notGreaterThan ?wc.
}.

{
    (?wm ?wt ?wc) :noMatch (?m ?t ?c).
}
<=
{
    ?t math:greaterThan ?wt.
}.

{
    (?wm ?wt ?wc) :noMatch (?m ?t ?c).
}
<=
{
    ?m math:greaterThan ?wm.
}.

{
    (?wm ?wt ?wc) :noMatch (?m ?t ?c).
}
<=
{
    ?c math:greaterThan ?wc.
}.


# POST solution intent
{
    ?operator :foundProblem ?problem;
              :operatorId ?wid.
    ?problem :trySolution ?solution.
    ?problem :occurredOnMachine ?machine.
    ?solution :solutionId ?sid;

              :worked ?tf;
              :report_comment ?comment.
    ?tf e:whenGround true.
    {?machine :state ?stopped.} :eventId ?eid.

}
=>
{
    _:request http:methodName "POST";
              tmpl:requestURI ("http://defects.tho.f4w.l0g.in/api/reports");
              http:body { rest:json
                     #I am not sure, but maybe this answers to the machine stopped event?
                    :event_id ?eid;
                    :operator_id ?wid;
                    :solution_id ?sid;
                    :success ?tf;
                    :comment ?comment
              }.
    ?solution :triedAndReported _:yes. #put "yes"
    ?solution :new :triple.
}.


# POST solution intent
{
    ?operator :foundProblem ?problem;
              :operatorId ?wid.
    ?problem :trySolution ?solution.
    ?solution :solutionId ?sid;
              :worked false;
              :report_comment ?comment.
    #?tf e:whenGround false.
    {?machine :state ?stopped.} :eventId ?eid.
}
=>
{
    _:request http:methodName "POST";
              tmpl:requestURI ("http://defects.tho.f4w.l0g.in/api/reports");
              http:body { rest:json
                     #I am not sure, but maybe this answers to the machine stopped event?
                    :event_id ?eid;
                    :operator_id ?wid;
                    :solution_id ?sid;
                    :success false;
                    :comment ?comment
              }.
    ?solution :triedAndReported _:yes. #put "yes"
    ?solution :tryNewSolution true.
    ?solution :new :triple.

}.

{
    ?problem :trySolution ?solution.
    ?solution :tryNewSolution true.
    _:l e:findall (?s {?solution :nextTry ?s.} ()).
    ?solution :solutionNo ?n.
    (1 ?n) math:sum ?m.
    ("solution" ?m) string:concatenation ?w.

    ?solution :name ?s_name;
              :desc ?s_desc;
              :comment ?s_comment.
}
=>
{
    ?solution :nextTry ?w.
    ?problem :trySolution ?w.
    ?w :solutionNo ?m.
    ?w :name ?s_name;
       :desc ?s_desc;
       :comment ?s_comment.
}.



{
    ?solution :triedAndReported ?yes;
              :worked ?tf.
    ?yes e:whenGround "yes".
    ?tf e:whenGround true.
    ?problem :occurredOnMachine ?machine.
    ?machine :machineID ?mid.
     ?problem        :trySolution ?solution.
   ?operator :foundProblem ?problem;
              :operatorId ?wid.
}
=>
{
    _:request http:methodName "POST";
              :check (?tf ?yes);
              tmpl:requestURI ("http://mstate.tho.f4w.l0g.in/api/machines/" ?mid "/events");
              http:body { rest:json
                     #I am not sure, but maybe this answers to the machine stopped event?
                    :name "Starting the machine";
                    :desc "Starting the machine after a solution was successfully applied!";
                    :operator_id ?wid;
                    :machine_state "1"
              }.
     ?machine :newState _:state.
    ?problem :finalState :solved.
}.


{
    ?problem :occurredOnMachine ?machine.
    ?problem :defect ?defect.
    {?machine :state ?state2.} :eventId ?eid.
    ?state2 e:whenGround "stopped1".
    ?machine #:state "notstopped2";
             :machineID ?mid.
    ?operator :foundProblem ?problem;
         :operatorId ?wid;
         :machineSkills ?wm;
         :toolSkills ?wt;
         :computerSkills ?wc.

    ?problem :trySolution ?solution.
    ?solution :solutionId ?id;
              :triedAndReported "no".
    ?solution :reqMachineSkills ?m;
        :reqToolSkills ?t;
        :reqComputerSkills ?c.

    (?wm ?wt ?wc ?m ?t ?c) e:whenGround (?wm2 ?wt2 ?wc2 ?m2 ?t2 ?c2).

    (?wm2 ?wt2 ?wc2) :noMatch (?m2 ?t2 ?c2).
}
=>
{
    _:request http:methodName "POST";
              :check (?wm ?m);
              tmpl:requestURI ("http://mstate.tho.f4w.l0g.in/api/machines/" ?mid "/events");
              http:body { rest:json
                  :name "waiting_for_teamleader";
                  :desc "Stoping the machine. Problem has to be fixed by the team leader.";
                  #TODO: put the right machine state
                  :machine_state "3";
                  :operator_id ?wid;
                  :optional { rest:json :defect_id ?defect; :stopped_for_defect_event_id ?eid }
              };
              http:resp [
                  http:body _:body
              ].
    _:body :contains { rest:json
        :id _:e
    }.

    {?machine :state _:stopped2.} :eventId _:e.
    ?machine :state _:stopped2. #please put "stopped2" here when grounding.
    ?problem :finalState :sentToTeamleader.
     ?machine :stateTL _:tl.
}.

{
 ?problem :finalState :solved.
?problem :occurredOnMachine ?m.
?m :machineID ?mid.
?m :newState ?state.
}=>{
_:request http:methodName "GET";
tmpl:requestURI ("http://askTheWorker/YouAreDone");
              :check ?state;
              http:body { rest:json
                  :message "Problem Solved."
              }.

?problem :tellTheWorker "solved".
}.


{
?problem :finalState :sentToTeamleader.
?problem :occurredOnMachine ?m.
?m :stateTL ?tl.
}=>{
_:request http:methodName "GET";
              tmpl:requestURI ("http://askTheWorker/SentToTeamLeader");
              :check ?tl;
              http:body { rest:json
                  :message "Teamleader was notified."
              }.

?problem :tellTheWorker ?stopped2.
}.









